/*
 * @Author: koi
 * @Date: 2025-09-06 11:09:19
 * @Description: 
 */
/*
 * @Author: koi
 * @Date: 2025-08-29 21:13:56
 * @Description:
 */

#include "BasicSymbolCollectOperator.h"
#include "../common/BufferUtils.h"
#include "BFSVersionManager.h"
#include "Facet.h"
#include "Halfedge.h"
#include "core.h"
#include "MeshUtils.h"
#include <vector>

void BasicSymbolCollectOperator::collect(MCGAL::Halfedge* seed) {
    std::deque<char> facetSym;
    std::deque<char> edgeSym;
    std::deque<MCGAL::Point> points;
    std::queue<int> gateQueue;
    gateQueue.push(seed->face()->poolId());
    int current_version = MCGAL::BfsVersionMananger::current_version++;
    int fcount = 0;
    std::vector<MCGAL::Facet*> faces;
    std::vector<MCGAL::Halfedge*> halfedges;
    while (!gateQueue.empty()) {
        int fid = gateQueue.front();
        MCGAL::Facet* f = MCGAL::contextPool.getFacetByIndex(mesh_->meshId(), fid);
        gateQueue.pop();
        if (f->isVisited(current_version) || f->isRemoved()) {
            continue;
        }
        f->setVisited(current_version);
        int vpoolId = -1;
        // int minVid = -1;
        MCGAL::Vertex* minV = (*f->halfedges_begin())->vertex();
        MCGAL::Halfedge* hIt = (*f->halfedges_begin());
        for (auto it = f->halfedges_begin(); it != f->halfedges_end(); it++) {
            MCGAL::Vertex* v = (*it)->vertex();
            if (MCGAL::compareVertex(v, minV)) {
                minV = v;
                hIt = (*it);
            }
        }
        MCGAL::Halfedge* h = hIt;
        unsigned sym = f->isSplittable();
        facetSym.push_back(sym);

        if (sym) {
            MCGAL::Point rmved = f->getRemovedVertexPos();
            points.push_back(rmved);
            fcount++;
            faces.push_back(f);
        }
        do {
            // unsigned sym;
            // if (hIt->isAdded()) {
            //     sym = 1;
            //     ecount++;
            // } else {
            //     sym = 0;
            // }
            // // if (!hIt->isVisited(current_version) && !hIt->opposite()->isVisited(current_version)) {
            // edgeSym.push_back(sym);
            // }

            MCGAL::Halfedge* hOpp = hIt->opposite();
            if (hOpp == nullptr) {
                hIt = hIt->next();
                continue;
            }
            if (!hOpp->face()->isVisited(current_version) && !hIt->isBoundary() && !hOpp->isBoundary()) {
                gateQueue.push(hOpp->face()->poolId());
            }
            hIt = hIt->next();
        } while (hIt != h);
    }

    gateQueue.push(seed->face()->poolId());
    current_version = MCGAL::BfsVersionMananger::current_version++;
    int ecount = 0;
    while (!gateQueue.empty()) {
        int fid = gateQueue.front();
        MCGAL::Facet* f = MCGAL::contextPool.getFacetByIndex(mesh_->meshId(), fid);
        gateQueue.pop();
        if (f->isVisited(current_version) || f->isRemoved()) {
            continue;
        }
        f->setVisited(current_version);
        int vpoolId = -1;
        // int minVid = -1;
        MCGAL::Vertex* minV = (*f->halfedges_begin())->vertex();
        MCGAL::Halfedge* hIt = (*f->halfedges_begin());
        for (auto it = f->halfedges_begin(); it != f->halfedges_end(); it++) {
            MCGAL::Vertex* v = (*it)->vertex();
            if (MCGAL::compareVertex(v, minV)) {
                minV = v;
                hIt = (*it);
            }
        }
        MCGAL::Halfedge* h = hIt;
        do {
            unsigned sym;
            if (hIt->isAdded()) {
                sym = 1;
                halfedges.push_back(hIt);
                ecount++;
            } else {
                sym = 0;
            }
            // if (!hIt->isVisited(current_version) && !hIt->opposite()->isVisited(current_version)) {
            edgeSym.push_back(sym);
            // }

            MCGAL::Halfedge* hOpp = hIt->opposite();
            if (hOpp == nullptr) {
                hIt = hIt->next();
                continue;
            }
            if (!hOpp->face()->isVisited(current_version) && !hIt->isBoundary() && !hOpp->isBoundary()) {
                gateQueue.push(hOpp->face()->poolId());
            }
            hIt = hIt->next();
        } while (hIt != h);
    }
    std::cout << "ecount: " << ecount << std::endl;
    std::cout << "fcount: " << fcount << std::endl;
    facetSymbolQueues.push_back(facetSym);
    edgeSymbolQueues.push_back(edgeSym);
    pointQueues.push_back(points);
}

int BasicSymbolCollectOperator::exportToBuffer(char* buffer) {
    int offset = 0;
    for (int i = facetSymbolQueues.size() - 1; i >= 0; i--) {
        std::deque<char> facetSym = facetSymbolQueues[i];
        std::deque<char> edgeSym = edgeSymbolQueues[i];
        std::deque<MCGAL::Point> points = pointQueues[i];
        while (!facetSym.empty()) {
            char sym = facetSym.front();
            facetSym.pop_front();
            writeChar(buffer, offset, sym);
            if (sym) {
                MCGAL::Point point = points.front();
                points.pop_front();
                writePoint(buffer, offset, point);
            }
        }
        while (!edgeSym.empty()) {
            char sym = edgeSym.front();
            edgeSym.pop_front();
            writeChar(buffer, offset, sym);
        }
    }
    return offset;
}